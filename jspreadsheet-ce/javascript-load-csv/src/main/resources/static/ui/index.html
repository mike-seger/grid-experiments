<html lang="en">
<head>
	<title>db adminux</title>

<!--
	<script src="https://jsuites.net/v4/jsuites.js"></script>
	<script src="https://jsuites.net/v4/jsuites.webcomponents.js"></script>
	<script src="https://bossanova.uk/jspreadsheet/v4/jexcel.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/d3-dsv@3"></script>

	<link rel="stylesheet" href="https://jsuites.net/v4/jsuites.css" type="text/css" />
	<link rel="stylesheet" href="https://bossanova.uk/jspreadsheet/v4/jexcel.css" type="text/css" />
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
-->	
	<script src="local/lib/jsuites.js"></script>
	<script src="local/lib/jsuites.webcomponents.js"></script>
	<script src="local/lib/jexcel.js"></script>
	<script src="local/lib/d3-dsv@3.js"></script>

	<link rel="stylesheet" href="local/lib/jsuites.css" type="text/css" />
	<link rel="stylesheet" href="local/lib/jexcel.css" type="text/css" />
	<link rel="stylesheet" href="local/lib/Material-Icons.css" />

	<link rel="stylesheet" href="jexcel-custom.css" type="text/css" charset="utf-8" />
	<link rel="stylesheet" href="jtoolbar-custom.css" type="text/css" charset="utf-8" />
	
	<style>
		body, html {
			overflow: hidden;
		}

		html {
			font-family: sans-serif;
		}

		body {
			overflow-x: auto;
			width: 100%;
		}

		.container {
			height: 100%;
			flex-direction: column;
			padding: 0;
			align-items: stretch;
			align-content: stretch; 
		}

		.content {
			flex: 1;
			box-sizing: border-box;
		}

		#toolbar {
			width: auto;
		}
	</style>
</head>
<body>
	<div class="container">
		<div id="toolbar"></div> 
		<div class="content" id="spreadsheet1"></div>
	</div>

	<jsuites-modal title="Saving Data" closed="true" width="600" height="400">
		Server response: <div id="servertext"></div>
	</jsuites-modal>

	<script>
	const spreadsheet1 = document.getElementById('spreadsheet1')
	const serverMessage = document.querySelector('jsuites-modal')
	const toolBar = document.getElementById('toolbar');
	const serverText = 	document.getElementById('servertext')

	const hMargin = 5;
	const dropdownMargin = 11;
	const calendarMargin = 30;
	const columnFilterTool = 4;
	const tableSearchTool = 5;

	let entityIds = [];
	let entities = {};
	let originalValiueHashes = {};
	let hiddenA = null;

	let downloadFormat = "TSV";
	let remoteBaseUri = location.port==8000? "../../db/changelog/data/" : "../api/v1/admin/csv";

	function stringWidth(text) {
		const font = "16px sans-serif"	
		const canvas = document.createElement("canvas");	
		const context = canvas.getContext("2d");	
		context.font = font;	
		const { width } = context.measureText(text);	
		return width;
	}

	const mWidth = stringWidth("M");

	function entityNames(entities) {
		return Object.keys((Object.fromEntries(Object.entries(entities).map(([k, entity]) => [entity.name]))))
	}

	function maxStringWidth(texts) {
		const max = texts.reduce((element,max) => 
			stringWidth(element) > stringWidth(max) ? element : max, 0)
		return stringWidth(max);
	}

	function autoResizeColumn(js, colIndex, header) {
		function findLongestString(arr) {
			return arr.reduce((a, b)=> a.length > b.length ? a : b);
		}

		const colConfig = getCurrentEntity().attributes[colIndex];
		console.log(colConfig);

		const longestString = findLongestString(js.getColumnData(colIndex));
		const sortableMargin = getCurrentEntity().sortable === true?dropdownMargin:0;
		let w = Math.max(stringWidth(longestString), stringWidth(header)+sortableMargin)+2*mWidth;
		if(colConfig.type === 'Enum') w += dropdownMargin;
		else if(colConfig.type.indexOf('Date')>=0) w += calendarMargin;
		js.setWidth(colIndex, w + 2*hMargin);
	}

	function autoResizeColumns(instance) {
		const js = instance.jspreadsheet;
		const headers = js.getHeaders().split(',');
		const data = js.getData();
		if(js.getData().length==0) return;
		for(let col = 0; col<headers.length; col++) 
			autoResizeColumn(js, col, headers[col])
	}

	function setColumnParams(js, col, header) {
		console.log(`col: ${col} - ${header}`);
	}

	function setAllColumnParams(instance, entity) {
		const js = instance.jspreadsheet;
		const headers = js.getHeaders().split(',');
		for(let col = 0; col<headers.length; col++) 
			setColumnParams(js, col, headers[col])
	}

	function cellChanged(instance, cell, col, row, value) {
		try {
			var cellName = jexcel.getColumnNameFromId([col,row]);
			console.log(`Change on cell (${col}, ${row}) ${cellName} to: ${value}`);
			const js = instance.jspreadsheet;
			const headers = js.getHeaders().split(',');
			autoResizeColumn(js, col, headers[col])
		} catch(e) {
			console.error(e);
		}
		return true;
	}

	function hashCode(s){
  		return s.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);              
	}

	function isRowModified(js, entity, row, rowIndex) {
		const s = row.join('');
		if(s.length==0) return false;
		const hc = hashCode(s);
		const allHc = js.getMeta();
		const originalHc = js.getMeta('A'+rowIndex).hc
		//const id = row[idIndex];
		return hc !== originalHc;
		//return hc !== originalValiueHashes[entity.name][id];
	}

	function isCurrentTableModified() {
		const data = getCurrentData();
		for(let i=1; i<data.length;i++) {
			if(data[i].join('').length>0) return true;
		}
		return false;
	}

	function getIdFieldIndex(entity) {
		return entity.attributes.findIndex(e => { return e.name === entity.idField; });
	}

	function cacheOriginalValueHashes(js, entity) {
		if(! entity.idField) return;
		const idIndex = getIdFieldIndex(entity);
		if(idIndex<0) return;
		const data = getCurrentData();
		originalValiueHashes[entity.name] = {};
		for(let i=1; i<data.length;i++) {
			const row = data[i];
			const id = row[idIndex];
			const hc = hashCode(row.join(''));
			originalValiueHashes[entity.name][id] = hc;
			js.setMeta('A'+i, 'hc', hc);
		}
	}

	function clearData(reset) {
		const js = getCurrentJexcel();
		if(reset) {
			var newData = [];
			newData.push(Array(getCurrentColumnsNames().length).fill(''));
			js.setData(newData);
		} else {
			const n = js.getData().length;
			js.insertRow(1,0,true);
			if(n>0) js.deleteRow(1, n);
		}
	}

	function beforeDeleteRow() {
    	console.log("beforeDeleteRow");
		const js = getCurrentJexcel();
		const n = js.getSelectedRows(false).length;
		if(js.getData().length <= n) {
			clearData(false);
			return false;
		}
		return true;
	}
	
	function customDeleteRow(...args) {
		if(!beforeDeleteRow()) {
			return false;
		}
		return getCurrentJexcel().originalDeleteRow(...args);
	}

	function setElementOffsetWidth(el, w, offsetW, hackerMode) {
		if(!el) {
			console.log('No el');
			return;
		}
		let newWidth = w+"px";
		el.style.width = '450px'
		const diff = el.offsetWidth - 450;
		const newW = Math.max(w - diff, 450) + offsetW;
		newWidth = newW+"px";
		el.style.width = newWidth;
		console.log("OW: "+el.classList+"\n"+w+" - "+newWidth+" - "+el.offsetWidth);
	}

	function resizeBars() {
		const js = getCurrentJexcel();
		const w = js.el.querySelector(".jexcel_content").offsetWidth;
		setElementOffsetWidth(document.getElementById("toolbar"), w, -1, true);
		//FIXME find a better solution than this hacky magic offset calculation
		setElementOffsetWidth(js.el, w, 4-(w-200)/500, true);
	}

	function loaded(instance) {
		console.log('New data is loaded');
		const entity = getCurrentEntity();
		const js = getCurrentJexcel();
		if(js.getData().length==0) {
			clearData(!originalValiueHashes[entity.name]);
			const data = js.getData();
			console.log(data);
		}

		if(!js.originalDeleteRow) {
			js.originalDeleteRow = js.deleteRow;
			js.deleteRow = customDeleteRow;
		}

		//TODO set meta information with hashCode on A1, A2, A3 ...
		//serves for later comparison when determinig "dirty" instead of originalValiueHashes
		//make it independant from identifiable
		//meta information should only be set as a result from a server data refresh
		//entity.idField and getIdFieldIndex

		autoResizeColumns(instance);
		console.log(entity);
		setAllColumnParams(instance, entity);
		initAllFilterStates();
		syncAllIconStates();
		cacheOriginalValueHashes(js, entity);
		resizeBars();	
	}

	function getCurrentSheetConfig() {
		return getCurrentJexcel().getConfig();
	}

	function getCurrentSheetColConfig(col) {
		return getCurrentSheetConfig().columns[col];
	}

	function directionSort(direction) {
		const col = getCurrentJexcel().selectedCoord.col;
		const type = getCurrentSheetColConfig(col).type;

		return function(a, b) {

			let valueA = a[1];
			let valueB = b[1];

			if(type === 'numeric') {
				valueA = new Number(a[1]);
				valueB = new Number(b[1]);
			}

			if (! direction) {
				return (valueA === '' && valueB !== '') ? 1 : (valueA !== '' && valueB === '') ? -1 : (valueA > valueB) ? 1 : (valueA < valueB) ? -1 :  0;
			} else {
				return (valueA === '' && valueB !== '') ? 1 : (valueA !== '' && valueB === '') ? -1 : (valueA > valueB) ? -1 : (valueA < valueB) ? 1 :  0;
			}
		}
	}

	function createColumns(attributes) {
		let columns = []
		for (const properties of attributes) {
			let column = {}
			const title = properties.title;
			console.log(properties);
			if(properties.hidden) column = {
				type: 'hidden', title: title, name: properties.name };
			else if(properties.type === "Float") column = {
				type: 'numeric', align: 'right', title: title, 
				name: properties.name, sorting: directionSort };
			else if(properties.type === "Int") column = {
				type: 'numeric', align: 'right', title: title, 
				name: properties.name, sorting: directionSort};
			else if(properties.type === "Enum") column = {
				type: 'dropdown', title: title, name: properties.name,
				source: properties.enumConstants};
			else column = {
				type: 'text', title: title, name: properties.name };
			columns.push(column);
		}
		return columns;
	}

	function tableChanged() {
		console.log("tableChanged");
	}

	function selected(target, col, row) {
		if(row!=0) return false;
		console.log(`selected: ${col} / ${row}`);
		getCurrentJexcel().selectedCoord = { col: col, row: row };
		return false;
	}

	function switchToEntity(entity) {
		let pos = entityIds.indexOf(entity.id)
		if(pos>=0) {
			selectWorkSheet(pos);
			return;
		}
		entityIds.push(entity.id);
		entities[entity.id] = entity;

		let columns = []
		if(entity.attributes) {
			columns = createColumns(entity.attributes);
			console.log(columns);
		}
		jspreadsheet.tabs(spreadsheet1, [{
			sheetName: entity.name,
			csv: remoteBaseUri+entity.getUri,
			columns: columns,
			csvHeaders:true,
			defaultColAlign: 'left',
			tableOverflow:true,
			tableHeight:'89%',
			onload: loaded,
			onchange: cellChanged,
			onselection: selected,
			onafterchanges: tableChanged,
			//onbeforedeleterow: beforeDeleteRow,
			allowInsertColumn: false,
			allowDeleteColumn: false,
			allowRenameColumn: false,
			allowManualInsertColumn: false,
			allowExport: false,
			rowResize: false,
			fillscreen: false,
			search: true,
			columnSorting: entity.sortable,
			filters: true,
			//toolbar: true,
			sorting: directionSort,
			//lazyLoading:true,
		    //loadingSpin:true,
		}]);
	}

	function downloadSvFile(fileName, data) {
		let result;
		let mimetype = "text/csv";
		if(downloadFormat == "TSV") {
			result = d3.tsvFormatBody(data);
			mimetype = "text/tab-separated-values";
		} else result = d3.csvFormatBody(data);
		if(hiddenA) hiddenA.remove();
		hiddenA = document.createElement('a');
		hiddenA.href = 'data:'+mimetype+';charset=utf-8,' + encodeURI(result);
		hiddenA.target = '_blank';
		hiddenA.download = fileName+'.'+downloadFormat.toLowerCase();
		hiddenA.click();
	}

	function getWorkSheetTabs() {
		return spreadsheet1.querySelectorAll('.jexcel_tab_link');
	}

	function getCurrentWorkSheetIndex() {
		return spreadsheet1.children[0].querySelector('.selected')
			.getAttribute('data-spreadsheet');
	}

	function getCurrentEntityId() {
		return entityIds[getCurrentWorkSheetIndex()];
	}

	function getCurrentEntity() {
		return entities[getCurrentEntityId()];
	}

	function selectWorkSheet(num) {
		const tabs = getWorkSheetTabs()
		if(!tabs || tabs.length<num) return;
		tabs[num].click();
		syncAllIconStates();
		resizeBars();
	}

	function getJexcel(num) {
		if(!spreadsheet1.children[0]) return undefined;
		let js = spreadsheet1.jexcel[num];
		if(js && !js.oldOrderBy && js.orderBy) {
			js.oldOrderBy  = js.orderBy;
		}
		return js;
	}

	function getCurrentJexcel() {
		if(!spreadsheet1.children[0]) return undefined;
		return getJexcel(getCurrentWorkSheetIndex());
	}

	function getCurrentColumnsNames() {
		return getCurrentEntity().attributes.map(a => a.name);
	}

	function getCurrentData() {
		const js =  getCurrentJexcel();
		if(!js) return [];
		let data = js.getData();
		data.splice(0, 0, getCurrentColumnsNames());
		return data;
	}

	function download() {
		const data = getCurrentData();
		console.log(data);
		if(data.length==0) return;
		downloadSvFile("data", data);
	}

	async function saveData(uriRoot, data, deleteAll) {
		if(data.length<=1) {
			return;
		}
		let uri = uriRoot;
		if(deleteAll) uri+="&deleteAll=true";
		const response = await fetch(uri, {
			method: 'PUT',
			headers: { 'Content-type': 'text/csv' },
			body: d3.csvFormatBody(data),
		});
		const responseMessage = await response.text();
		serverText.innerText = responseMessage;
		serverMessage.modal.open();
		console.log(responseMessage);
	}

	async function deleteIds(uri, deletedIds) {
		if(deletedIds.length<=0) {
			return;
		}
		const params = new URLSearchParams(deletedIds.map(id=>['id',id]));
		const searchString = params.toString();
		const response = await fetch(uri+params.toString(), {
			method: 'DELETE'
		});
		const responseMessage = await response.text();
		serverText.innerText = responseMessage;
		serverMessage.modal.open();
		console.log(responseMessage);
	}

	function getModifiedData(js, entity, data) {
		if(! entity.idField) return data;
		const idIndex = getIdFieldIndex(entity);
		if(idIndex<0) return data;
		let modifiedData = []
		modifiedData.push(data[0]);
		for(let i=1; i<data.length;i++) {
			const row = data[i];
			if(isRowModified(js, entity, row, i)) {
				modifiedData.push(row);
			}
		}
		return modifiedData;
	}

	function getDeletedIds(entity, data) {
		if(! entity.idField) return [];
		const idIndex = getIdFieldIndex(entity);
		if(idIndex<0) return [];
		const ids = Object.keys(originalValiueHashes[entity.name]);
		const currIds = data.map(r => r[idIndex]);
		const deletedIds = ids.filter( x => !currIds.includes(x) );
		return deletedIds;
	}

	function save(entities) {
		const data = getCurrentData();
		const js = getCurrentJexcel();
		console.log(data);
		if(data.length===0) return;
		console.log("Save data...: "+getCurrentEntityId());
		const entity = entities[getCurrentEntityId()];
		const saveUri = remoteBaseUri + entity.putUri;
		const deleteUri = remoteBaseUri + entity.deleteUri;
		console.log("URI: "+saveUri);
		if(entity.idField) {
			const modifiedData = getModifiedData(js, entity, data);
			const deletedIds = getDeletedIds(entity, data);
			deleteIds(deleteUri, deletedIds)
			saveData(saveUri, modifiedData, false);
		} else {
			saveData(saveUri, data, true);
		}
		cacheOriginalValueHashes(js, entity);
	}

	function syncIconStates(selector, iconIndex) {
		const filterRow = getCurrentJexcel().el.querySelector(selector);
		if(filterRow) {
			const filterState = !(filterRow.style.display === 'none');
			const toolBarItems = toolBar.querySelectorAll(".jtoolbar-item");
			console.log("filterState - "+ selector +":"+filterState);
			if(toolBarItems && toolBarItems.length>iconIndex) {
				if(filterState) toolBarItems[iconIndex].classList.add("jtoolbar-active");
				else toolBarItems[iconIndex].classList.remove("jtoolbar-active");
			}
		}
	}

	function syncAllIconStates() {
		syncIconStates('.jexcel > thead > tr:nth-child(2)', columnFilterTool);
		syncIconStates('.jexcel_filter', tableSearchTool);
	}

	function initFilterState(selector) {
		const filterRow = getCurrentJexcel().el.querySelector(selector);
		if(filterRow) filterRow.style.display = 'none';
	}

	function initAllFilterStates() {
		initFilterState('.jexcel > thead tr:nth-child(2)');
		initFilterState('.jexcel_filter');
	}

	function toggleFunc(icon, selector) {
		const js = getCurrentJexcel();
		if(!js) return true;
		icon.classList.toggle("jtoolbar-active");
		const filterRow = js.el.querySelector(selector);
		if(filterRow) {
			const active = filterRow.style.display !== 'none';
			if(active) filterRow.style.display = "none";
			else filterRow.style.display=null;
		}
	}

	function createToolbar(entities) {
		jSuites.toolbar(toolBar, {
			container: true,
			items:[
				{
					type: 'select',
					data: Object.keys(entities),
					render: function(e) { return '<span>' + entities[e].name + '</span>'; },
					width: maxStringWidth(entityNames(entities))+2*mWidth,
					onchange: function(a,b,c,d) { switchToEntity(entities[d]); }
				},
				{
					type: 'icon',
					content: 'save',
					onclick: function() { save(entities); }
				},
				{
					type: 'select',
					data: ["TSV", "CSV"],
					onchange: function(a,b,c,value) { downloadFormat = value; }
				},
				{
					type: 'icon',
					content: 'vertical_align_bottom',
					onclick: download
				},
				{
					type: 'icon',
					content: 'filter_list',
					onclick: function(a,b,c) {
						return toggleFunc(c,'.jexcel > thead > tr:nth-child(2)');
					},
					state: true,
					active: false,
				},
				{
					type: 'icon',
					content: 'search',
					onclick: function(a,b,c) {
						resizeBars();
						const result = toggleFunc(c, '.jexcel_filter');
						return result;
					},
					state: true,
					active: false,
				}
			]
		});
	}

	async function loadConfiguration() {
		const configUrl = location.port==8000? remoteBaseUri+'config.json' : remoteBaseUri+'/configuration'
		const response = await fetch(configUrl);
		const configuration = await response.json();
		console.log(configuration);
		const entities = configuration.entities;
		console.log(Object.keys(entities));
		createToolbar(entities);
	}

	loadConfiguration();
	</script>
</body>
</html>
